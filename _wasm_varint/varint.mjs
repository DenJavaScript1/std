// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
// This file is automatically @generated by _build.ts
// It is not intended for manual editing.
// deno-lint-ignore-file
import wasmBytes from "./varint.wasm.mjs";

let cachegetInt32Memory0 = null;
function getInt32Memory0() {
  if (
    cachegetInt32Memory0 === null ||
    cachegetInt32Memory0.buffer !== wasm.memory.buffer
  ) {
    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachegetInt32Memory0;
}

let cachegetUint8Memory0 = null;
function getUint8Memory0() {
  if (
    cachegetUint8Memory0 === null ||
    cachegetUint8Memory0.buffer !== wasm.memory.buffer
  ) {
    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachegetUint8Memory0;
}

function getArrayU8FromWasm0(ptr, len) {
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
 * @param {number} val
 * @returns {Uint8Array}
 */
export function encode_u32(val) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.encode_u32(retptr, val);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var v0 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_free(r0, r1 * 1);
    return v0;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}

const u32CvtShim = new Uint32Array(2);

const uint64CvtShim = new BigUint64Array(u32CvtShim.buffer);
/**
 * @param {BigInt} val
 * @returns {Uint8Array}
 */
export function encode_u64(val) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    uint64CvtShim[0] = val;
    const low0 = u32CvtShim[0];
    const high0 = u32CvtShim[1];
    wasm.encode_u64(retptr, low0, high0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    var v1 = getArrayU8FromWasm0(r0, r1).slice();
    wasm.__wbindgen_free(r0, r1 * 1);
    return v1;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}

let WASM_VECTOR_LEN = 0;

function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1);
  getUint8Memory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
/**
 * @param {Uint8Array} buff
 * @returns {number}
 */
export function decode_u32(buff) {
  var ptr0 = passArray8ToWasm0(buff, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  var ret = wasm.decode_u32(ptr0, len0);
  return ret >>> 0;
}

/**
 * @param {Uint8Array} buff
 * @returns {BigInt}
 */
export function decode_u64(buff) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    var ptr0 = passArray8ToWasm0(buff, wasm.__wbindgen_malloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.decode_u64(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    u32CvtShim[0] = r0;
    u32CvtShim[1] = r1;
    const n1 = uint64CvtShim[0];
    return n1;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}

const imports = {
  __wbindgen_placeholder__: {},
};

const wasmModule = new WebAssembly.Module(wasmBytes);
const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
const wasm = wasmInstance.exports;

// for testing/debugging
export const _wasm = wasm;
export const _wasmModule = wasmModule;
export const _wasmInstance = wasmInstance;
export const _wasmBytes = wasmBytes;
